// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// AuthorDetailBooksItem defines model for AuthorDetailBooksItem.
type AuthorDetailBooksItem struct {
	Description string `json:"description"`
	Id          string `json:"id"`
	Image       Image  `json:"image"`
	Name        string `json:"name"`
}

// EpisodesPagesItem defines model for EpisodesPagesItem.
type EpisodesPagesItem struct {
	Id    string  `json:"id"`
	Image Image   `json:"image"`
	Page  float32 `json:"page"`
}

// GetAuthorDetail defines model for GetAuthorDetail.
type GetAuthorDetail struct {
	Books       *[]AuthorDetailBooksItem `json:"books,omitempty"`
	Description *string                  `json:"description,omitempty"`
	Id          *string                  `json:"id,omitempty"`
	Name        *string                  `json:"name,omitempty"`
}

// GetAuthorListItem defines model for GetAuthorListItem.
type GetAuthorListItem struct {
	Books []struct {
		Description string `json:"description"`
		Episodes    []struct {
			Chapter     float32 `json:"chapter"`
			Description string  `json:"description"`
			Id          string  `json:"id"`
			Name        string  `json:"name"`
		} `json:"episodes"`
		Id    string `json:"id"`
		Image Image  `json:"image"`
		Name  string `json:"name"`
	} `json:"books"`
	Description string `json:"description"`
	Id          string `json:"id"`
	Image       Image  `json:"image"`
	Name        string `json:"name"`
}

// GetBooksDetail defines model for GetBooksDetail.
type GetBooksDetail struct {
	Author struct {
		Id    string `json:"id"`
		Image Image  `json:"image"`
		Name  string `json:"name"`
	} `json:"author"`
	Description string `json:"description"`
	Episodes    []struct {
		Id string `json:"id"`
	} `json:"episodes"`
	Id       string `json:"id"`
	Image    Image  `json:"image"`
	Name     string `json:"name"`
	NameRuby string `json:"nameRuby"`
}

// GetEpisodes defines model for GetEpisodes.
type GetEpisodes struct {
	Book struct {
		Author struct {
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       struct {
				Alt string `json:"alt"`
				Id  string `json:"id"`
			} `json:"image"`
			Name string `json:"name"`
		} `json:"author"`
		Description string `json:"description"`
		Id          string `json:"id"`
		Image       Image  `json:"image"`
		Name        string `json:"name"`
		NameRuby    string `json:"nameRuby"`
	} `json:"book"`
	Chapter     float32             `json:"chapter"`
	Description string              `json:"description"`
	Id          string              `json:"id"`
	Image       Image               `json:"image"`
	Name        string              `json:"name"`
	NameRuby    string              `json:"nameRuby"`
	Pages       []EpisodesPagesItem `json:"pages"`
}

// GetRankingsItem defines model for GetRankingsItem.
type GetRankingsItem struct {
	Book RankingsItemBook `json:"book"`
	Id   string           `json:"id"`
	Rank float32          `json:"rank"`
}

// Image defines model for Image.
type Image struct {
	Alt string `json:"alt"`
	Id  string `json:"id"`
}

// RankingsItemBook defines model for RankingsItemBook.
type RankingsItemBook struct {
	Author      RankingsItemBookAuthor `json:"author"`
	Description string                 `json:"description"`
	Id          string                 `json:"id"`
	Image       Image                  `json:"image"`
	Name        string                 `json:"name"`
}

// RankingsItemBookAuthor defines model for RankingsItemBookAuthor.
type RankingsItemBookAuthor struct {
	Description string `json:"description"`
	Id          string `json:"id"`
	Image       Image  `json:"image"`
	Name        string `json:"name"`
}

// PostAdminLoginJSONBody defines parameters for PostAdminLogin.
type PostAdminLoginJSONBody struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// GetAuthorsParams defines parameters for GetAuthors.
type GetAuthorsParams struct {
	Limit  *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	Name   *string  `form:"name,omitempty" json:"name,omitempty"`
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostAuthorsJSONBody defines parameters for PostAuthors.
type PostAuthorsJSONBody struct {
	Description string `json:"description"`
	ImageId     string `json:"imageId"`
	Name        string `json:"name"`
}

// PatchAuthorsAuthorIdJSONBody defines parameters for PatchAuthorsAuthorId.
type PatchAuthorsAuthorIdJSONBody struct {
	Description *string `json:"description,omitempty"`
	ImageId     *string `json:"imageId,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// GetBooksParams defines parameters for GetBooks.
type GetBooksParams struct {
	AuthorId   *string  `form:"authorId,omitempty" json:"authorId,omitempty"`
	AuthorName *string  `form:"authorName,omitempty" json:"authorName,omitempty"`
	Limit      *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	Name       *string  `form:"name,omitempty" json:"name,omitempty"`
	Offset     *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostBooksJSONBody defines parameters for PostBooks.
type PostBooksJSONBody struct {
	AuthorId    string `json:"authorId"`
	Description string `json:"description"`
	ImageId     string `json:"imageId"`
	Name        string `json:"name"`
	NameRuby    string `json:"nameRuby"`
	ReleaseId   string `json:"releaseId"`
}

// PatchBooksBookIdJSONBody defines parameters for PatchBooksBookId.
type PatchBooksBookIdJSONBody struct {
	AuthorId    *string `json:"authorId,omitempty"`
	Description *string `json:"description,omitempty"`
	ImageId     *string `json:"imageId,omitempty"`
	Name        *string `json:"name,omitempty"`
	NameRuby    *string `json:"nameRuby,omitempty"`
	ReleaseId   *string `json:"releaseId,omitempty"`
}

// GetEpisodePagesParams defines parameters for GetEpisodePages.
type GetEpisodePagesParams struct {
	EpisodeId string   `form:"episodeId" json:"episodeId"`
	Limit     *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostEpisodePagesJSONBody defines parameters for PostEpisodePages.
type PostEpisodePagesJSONBody struct {
	EpisodeId string  `json:"episodeId"`
	Id        *string `json:"id,omitempty"`
	ImageId   string  `json:"imageId"`
	Page      float32 `json:"page"`
}

// PatchEpisodePagesEpisodePageIdJSONBody defines parameters for PatchEpisodePagesEpisodePageId.
type PatchEpisodePagesEpisodePageIdJSONBody struct {
	EpisodeId *string  `json:"episodeId,omitempty"`
	Id        *string  `json:"id,omitempty"`
	ImageId   *string  `json:"imageId,omitempty"`
	Page      *float32 `json:"page,omitempty"`
}

// GetEpisodesParams defines parameters for GetEpisodes.
type GetEpisodesParams struct {
	BookId string   `form:"bookId" json:"bookId"`
	Limit  *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostEpisodesJSONBody defines parameters for PostEpisodes.
type PostEpisodesJSONBody struct {
	BookId      string  `json:"bookId"`
	Chapter     float32 `json:"chapter"`
	Description string  `json:"description"`
	ImageId     string  `json:"imageId"`
	Name        string  `json:"name"`
	NameRuby    string  `json:"nameRuby"`
}

// PatchEpisodesEpisodeIdJSONBody defines parameters for PatchEpisodesEpisodeId.
type PatchEpisodesEpisodeIdJSONBody struct {
	BookId      *string  `json:"bookId,omitempty"`
	Chapter     *float32 `json:"chapter,omitempty"`
	Description *string  `json:"description,omitempty"`
	ImageId     *string  `json:"imageId,omitempty"`
	Name        *string  `json:"name,omitempty"`
	NameRuby    *string  `json:"nameRuby,omitempty"`
}

// GetFeaturesParams defines parameters for GetFeatures.
type GetFeaturesParams struct {
	Limit  *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostImagesMultipartBody defines parameters for PostImages.
type PostImagesMultipartBody struct {
	Alt     string              `json:"alt"`
	Content *openapi_types.File `json:"content,omitempty"`
}

// GetRankingsParams defines parameters for GetRankings.
type GetRankingsParams struct {
	Limit  *float32 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// PostAdminLoginJSONRequestBody defines body for PostAdminLogin for application/json ContentType.
type PostAdminLoginJSONRequestBody PostAdminLoginJSONBody

// PostAuthorsJSONRequestBody defines body for PostAuthors for application/json ContentType.
type PostAuthorsJSONRequestBody PostAuthorsJSONBody

// PatchAuthorsAuthorIdJSONRequestBody defines body for PatchAuthorsAuthorId for application/json ContentType.
type PatchAuthorsAuthorIdJSONRequestBody PatchAuthorsAuthorIdJSONBody

// PostBooksJSONRequestBody defines body for PostBooks for application/json ContentType.
type PostBooksJSONRequestBody PostBooksJSONBody

// PatchBooksBookIdJSONRequestBody defines body for PatchBooksBookId for application/json ContentType.
type PatchBooksBookIdJSONRequestBody PatchBooksBookIdJSONBody

// PostEpisodePagesJSONRequestBody defines body for PostEpisodePages for application/json ContentType.
type PostEpisodePagesJSONRequestBody PostEpisodePagesJSONBody

// PatchEpisodePagesEpisodePageIdJSONRequestBody defines body for PatchEpisodePagesEpisodePageId for application/json ContentType.
type PatchEpisodePagesEpisodePageIdJSONRequestBody PatchEpisodePagesEpisodePageIdJSONBody

// PostEpisodesJSONRequestBody defines body for PostEpisodes for application/json ContentType.
type PostEpisodesJSONRequestBody PostEpisodesJSONBody

// PatchEpisodesEpisodeIdJSONRequestBody defines body for PatchEpisodesEpisodeId for application/json ContentType.
type PatchEpisodesEpisodeIdJSONRequestBody PatchEpisodesEpisodeIdJSONBody

// PostImagesMultipartRequestBody defines body for PostImages for multipart/form-data ContentType.
type PostImagesMultipartRequestBody PostImagesMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAdminLoginWithBody request with any body
	PostAdminLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAdminLogin(ctx context.Context, body PostAdminLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAdminLogout request
	PostAdminLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdminMe request
	GetAdminMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthors request
	GetAuthors(ctx context.Context, params *GetAuthorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorsWithBody request with any body
	PostAuthorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthors(ctx context.Context, body PostAuthorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthorsAuthorId request
	DeleteAuthorsAuthorId(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorsAuthorId request
	GetAuthorsAuthorId(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAuthorsAuthorIdWithBody request with any body
	PatchAuthorsAuthorIdWithBody(ctx context.Context, authorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAuthorsAuthorId(ctx context.Context, authorId string, body PatchAuthorsAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBooks request
	GetBooks(ctx context.Context, params *GetBooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBooksWithBody request with any body
	PostBooksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBooks(ctx context.Context, body PostBooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBooksBookId request
	DeleteBooksBookId(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBooksBookId request
	GetBooksBookId(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchBooksBookIdWithBody request with any body
	PatchBooksBookIdWithBody(ctx context.Context, bookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchBooksBookId(ctx context.Context, bookId string, body PatchBooksBookIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodePages request
	GetEpisodePages(ctx context.Context, params *GetEpisodePagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEpisodePagesWithBody request with any body
	PostEpisodePagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEpisodePages(ctx context.Context, body PostEpisodePagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEpisodePagesEpisodePageId request
	DeleteEpisodePagesEpisodePageId(ctx context.Context, episodePageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchEpisodePagesEpisodePageIdWithBody request with any body
	PatchEpisodePagesEpisodePageIdWithBody(ctx context.Context, episodePageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchEpisodePagesEpisodePageId(ctx context.Context, episodePageId string, body PatchEpisodePagesEpisodePageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodePagesPageId request
	GetEpisodePagesPageId(ctx context.Context, pageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodes request
	GetEpisodes(ctx context.Context, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEpisodesWithBody request with any body
	PostEpisodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEpisodes(ctx context.Context, body PostEpisodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEpisodesEpisodeId request
	DeleteEpisodesEpisodeId(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEpisodesEpisodeId request
	GetEpisodesEpisodeId(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchEpisodesEpisodeIdWithBody request with any body
	PatchEpisodesEpisodeIdWithBody(ctx context.Context, episodeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchEpisodesEpisodeId(ctx context.Context, episodeId string, body PatchEpisodesEpisodeIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeatures request
	GetFeatures(ctx context.Context, params *GetFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostImagesWithBody request with any body
	PostImagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInitialize request
	PostInitialize(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRankings request
	GetRankings(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleases request
	GetReleases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleasesDayOfWeek request
	GetReleasesDayOfWeek(ctx context.Context, dayOfWeek string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAdminLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdminLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAdminLogin(ctx context.Context, body PostAdminLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdminLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAdminLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdminLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdminMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdminMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthors(ctx context.Context, params *GetAuthorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthors(ctx context.Context, body PostAuthorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthorsAuthorId(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorsAuthorIdRequest(c.Server, authorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorsAuthorId(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorsAuthorIdRequest(c.Server, authorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAuthorsAuthorIdWithBody(ctx context.Context, authorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAuthorsAuthorIdRequestWithBody(c.Server, authorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAuthorsAuthorId(ctx context.Context, authorId string, body PatchAuthorsAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAuthorsAuthorIdRequest(c.Server, authorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBooks(ctx context.Context, params *GetBooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBooksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBooksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBooks(ctx context.Context, body PostBooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBooksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBooksBookId(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBooksBookIdRequest(c.Server, bookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBooksBookId(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBooksBookIdRequest(c.Server, bookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBooksBookIdWithBody(ctx context.Context, bookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBooksBookIdRequestWithBody(c.Server, bookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBooksBookId(ctx context.Context, bookId string, body PatchBooksBookIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBooksBookIdRequest(c.Server, bookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodePages(ctx context.Context, params *GetEpisodePagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodePagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEpisodePagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEpisodePagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEpisodePages(ctx context.Context, body PostEpisodePagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEpisodePagesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEpisodePagesEpisodePageId(ctx context.Context, episodePageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEpisodePagesEpisodePageIdRequest(c.Server, episodePageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEpisodePagesEpisodePageIdWithBody(ctx context.Context, episodePageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEpisodePagesEpisodePageIdRequestWithBody(c.Server, episodePageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEpisodePagesEpisodePageId(ctx context.Context, episodePageId string, body PatchEpisodePagesEpisodePageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEpisodePagesEpisodePageIdRequest(c.Server, episodePageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodePagesPageId(ctx context.Context, pageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodePagesPageIdRequest(c.Server, pageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodes(ctx context.Context, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEpisodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEpisodesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEpisodes(ctx context.Context, body PostEpisodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEpisodesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEpisodesEpisodeId(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEpisodesEpisodeIdRequest(c.Server, episodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEpisodesEpisodeId(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEpisodesEpisodeIdRequest(c.Server, episodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEpisodesEpisodeIdWithBody(ctx context.Context, episodeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEpisodesEpisodeIdRequestWithBody(c.Server, episodeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEpisodesEpisodeId(ctx context.Context, episodeId string, body PatchEpisodesEpisodeIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEpisodesEpisodeIdRequest(c.Server, episodeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeatures(ctx context.Context, params *GetFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeaturesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostImagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostImagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInitialize(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInitializeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRankings(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRankingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleasesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleasesDayOfWeek(ctx context.Context, dayOfWeek string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleasesDayOfWeekRequest(c.Server, dayOfWeek)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAdminLoginRequest calls the generic PostAdminLogin builder with application/json body
func NewPostAdminLoginRequest(server string, body PostAdminLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAdminLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAdminLoginRequestWithBody generates requests for PostAdminLogin with any type of body
func NewPostAdminLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostAdminLogoutRequest generates requests for PostAdminLogout
func NewPostAdminLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAdminMeRequest generates requests for GetAdminMe
func NewGetAdminMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorsRequest generates requests for GetAuthors
func NewGetAuthorsRequest(server string, params *GetAuthorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthorsRequest calls the generic PostAuthors builder with application/json body
func NewPostAuthorsRequest(server string, body PostAuthorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthorsRequestWithBody generates requests for PostAuthors with any type of body
func NewPostAuthorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthorsAuthorIdRequest generates requests for DeleteAuthorsAuthorId
func NewDeleteAuthorsAuthorIdRequest(server string, authorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorId", runtime.ParamLocationPath, authorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorsAuthorIdRequest generates requests for GetAuthorsAuthorId
func NewGetAuthorsAuthorIdRequest(server string, authorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorId", runtime.ParamLocationPath, authorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAuthorsAuthorIdRequest calls the generic PatchAuthorsAuthorId builder with application/json body
func NewPatchAuthorsAuthorIdRequest(server string, authorId string, body PatchAuthorsAuthorIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAuthorsAuthorIdRequestWithBody(server, authorId, "application/json", bodyReader)
}

// NewPatchAuthorsAuthorIdRequestWithBody generates requests for PatchAuthorsAuthorId with any type of body
func NewPatchAuthorsAuthorIdRequestWithBody(server string, authorId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorId", runtime.ParamLocationPath, authorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBooksRequest generates requests for GetBooks
func NewGetBooksRequest(server string, params *GetBooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/books")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AuthorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorId", runtime.ParamLocationQuery, *params.AuthorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorName", runtime.ParamLocationQuery, *params.AuthorName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBooksRequest calls the generic PostBooks builder with application/json body
func NewPostBooksRequest(server string, body PostBooksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBooksRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBooksRequestWithBody generates requests for PostBooks with any type of body
func NewPostBooksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/books")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBooksBookIdRequest generates requests for DeleteBooksBookId
func NewDeleteBooksBookIdRequest(server string, bookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookId", runtime.ParamLocationPath, bookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/books/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBooksBookIdRequest generates requests for GetBooksBookId
func NewGetBooksBookIdRequest(server string, bookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookId", runtime.ParamLocationPath, bookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/books/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchBooksBookIdRequest calls the generic PatchBooksBookId builder with application/json body
func NewPatchBooksBookIdRequest(server string, bookId string, body PatchBooksBookIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchBooksBookIdRequestWithBody(server, bookId, "application/json", bodyReader)
}

// NewPatchBooksBookIdRequestWithBody generates requests for PatchBooksBookId with any type of body
func NewPatchBooksBookIdRequestWithBody(server string, bookId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookId", runtime.ParamLocationPath, bookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/books/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEpisodePagesRequest generates requests for GetEpisodePages
func NewGetEpisodePagesRequest(server string, params *GetEpisodePagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodePages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "episodeId", runtime.ParamLocationQuery, params.EpisodeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEpisodePagesRequest calls the generic PostEpisodePages builder with application/json body
func NewPostEpisodePagesRequest(server string, body PostEpisodePagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEpisodePagesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEpisodePagesRequestWithBody generates requests for PostEpisodePages with any type of body
func NewPostEpisodePagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodePages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEpisodePagesEpisodePageIdRequest generates requests for DeleteEpisodePagesEpisodePageId
func NewDeleteEpisodePagesEpisodePageIdRequest(server string, episodePageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "episodePageId", runtime.ParamLocationPath, episodePageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodePages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchEpisodePagesEpisodePageIdRequest calls the generic PatchEpisodePagesEpisodePageId builder with application/json body
func NewPatchEpisodePagesEpisodePageIdRequest(server string, episodePageId string, body PatchEpisodePagesEpisodePageIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchEpisodePagesEpisodePageIdRequestWithBody(server, episodePageId, "application/json", bodyReader)
}

// NewPatchEpisodePagesEpisodePageIdRequestWithBody generates requests for PatchEpisodePagesEpisodePageId with any type of body
func NewPatchEpisodePagesEpisodePageIdRequestWithBody(server string, episodePageId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "episodePageId", runtime.ParamLocationPath, episodePageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodePages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEpisodePagesPageIdRequest generates requests for GetEpisodePagesPageId
func NewGetEpisodePagesPageIdRequest(server string, pageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pageId", runtime.ParamLocationPath, pageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodePages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEpisodesRequest generates requests for GetEpisodes
func NewGetEpisodesRequest(server string, params *GetEpisodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bookId", runtime.ParamLocationQuery, params.BookId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEpisodesRequest calls the generic PostEpisodes builder with application/json body
func NewPostEpisodesRequest(server string, body PostEpisodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEpisodesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEpisodesRequestWithBody generates requests for PostEpisodes with any type of body
func NewPostEpisodesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEpisodesEpisodeIdRequest generates requests for DeleteEpisodesEpisodeId
func NewDeleteEpisodesEpisodeIdRequest(server string, episodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "episodeId", runtime.ParamLocationPath, episodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEpisodesEpisodeIdRequest generates requests for GetEpisodesEpisodeId
func NewGetEpisodesEpisodeIdRequest(server string, episodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "episodeId", runtime.ParamLocationPath, episodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchEpisodesEpisodeIdRequest calls the generic PatchEpisodesEpisodeId builder with application/json body
func NewPatchEpisodesEpisodeIdRequest(server string, episodeId string, body PatchEpisodesEpisodeIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchEpisodesEpisodeIdRequestWithBody(server, episodeId, "application/json", bodyReader)
}

// NewPatchEpisodesEpisodeIdRequestWithBody generates requests for PatchEpisodesEpisodeId with any type of body
func NewPatchEpisodesEpisodeIdRequestWithBody(server string, episodeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "episodeId", runtime.ParamLocationPath, episodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/episodes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFeaturesRequest generates requests for GetFeatures
func NewGetFeaturesRequest(server string, params *GetFeaturesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostImagesRequestWithBody generates requests for PostImages with any type of body
func NewPostImagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostInitializeRequest generates requests for PostInitialize
func NewPostInitializeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/initialize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRankingsRequest generates requests for GetRankings
func NewGetRankingsRequest(server string, params *GetRankingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rankings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleasesRequest generates requests for GetReleases
func NewGetReleasesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/releases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReleasesDayOfWeekRequest generates requests for GetReleasesDayOfWeek
func NewGetReleasesDayOfWeekRequest(server string, dayOfWeek string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dayOfWeek", runtime.ParamLocationPath, dayOfWeek)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/releases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAdminLoginWithBodyWithResponse request with any body
	PostAdminLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAdminLoginResponse, error)

	PostAdminLoginWithResponse(ctx context.Context, body PostAdminLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAdminLoginResponse, error)

	// PostAdminLogoutWithResponse request
	PostAdminLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAdminLogoutResponse, error)

	// GetAdminMeWithResponse request
	GetAdminMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAdminMeResponse, error)

	// GetAuthorsWithResponse request
	GetAuthorsWithResponse(ctx context.Context, params *GetAuthorsParams, reqEditors ...RequestEditorFn) (*GetAuthorsResponse, error)

	// PostAuthorsWithBodyWithResponse request with any body
	PostAuthorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorsResponse, error)

	PostAuthorsWithResponse(ctx context.Context, body PostAuthorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorsResponse, error)

	// DeleteAuthorsAuthorIdWithResponse request
	DeleteAuthorsAuthorIdWithResponse(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*DeleteAuthorsAuthorIdResponse, error)

	// GetAuthorsAuthorIdWithResponse request
	GetAuthorsAuthorIdWithResponse(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*GetAuthorsAuthorIdResponse, error)

	// PatchAuthorsAuthorIdWithBodyWithResponse request with any body
	PatchAuthorsAuthorIdWithBodyWithResponse(ctx context.Context, authorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAuthorsAuthorIdResponse, error)

	PatchAuthorsAuthorIdWithResponse(ctx context.Context, authorId string, body PatchAuthorsAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAuthorsAuthorIdResponse, error)

	// GetBooksWithResponse request
	GetBooksWithResponse(ctx context.Context, params *GetBooksParams, reqEditors ...RequestEditorFn) (*GetBooksResponse, error)

	// PostBooksWithBodyWithResponse request with any body
	PostBooksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBooksResponse, error)

	PostBooksWithResponse(ctx context.Context, body PostBooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBooksResponse, error)

	// DeleteBooksBookIdWithResponse request
	DeleteBooksBookIdWithResponse(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*DeleteBooksBookIdResponse, error)

	// GetBooksBookIdWithResponse request
	GetBooksBookIdWithResponse(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*GetBooksBookIdResponse, error)

	// PatchBooksBookIdWithBodyWithResponse request with any body
	PatchBooksBookIdWithBodyWithResponse(ctx context.Context, bookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBooksBookIdResponse, error)

	PatchBooksBookIdWithResponse(ctx context.Context, bookId string, body PatchBooksBookIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBooksBookIdResponse, error)

	// GetEpisodePagesWithResponse request
	GetEpisodePagesWithResponse(ctx context.Context, params *GetEpisodePagesParams, reqEditors ...RequestEditorFn) (*GetEpisodePagesResponse, error)

	// PostEpisodePagesWithBodyWithResponse request with any body
	PostEpisodePagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEpisodePagesResponse, error)

	PostEpisodePagesWithResponse(ctx context.Context, body PostEpisodePagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEpisodePagesResponse, error)

	// DeleteEpisodePagesEpisodePageIdWithResponse request
	DeleteEpisodePagesEpisodePageIdWithResponse(ctx context.Context, episodePageId string, reqEditors ...RequestEditorFn) (*DeleteEpisodePagesEpisodePageIdResponse, error)

	// PatchEpisodePagesEpisodePageIdWithBodyWithResponse request with any body
	PatchEpisodePagesEpisodePageIdWithBodyWithResponse(ctx context.Context, episodePageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEpisodePagesEpisodePageIdResponse, error)

	PatchEpisodePagesEpisodePageIdWithResponse(ctx context.Context, episodePageId string, body PatchEpisodePagesEpisodePageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEpisodePagesEpisodePageIdResponse, error)

	// GetEpisodePagesPageIdWithResponse request
	GetEpisodePagesPageIdWithResponse(ctx context.Context, pageId string, reqEditors ...RequestEditorFn) (*GetEpisodePagesPageIdResponse, error)

	// GetEpisodesWithResponse request
	GetEpisodesWithResponse(ctx context.Context, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*GetEpisodesResponse, error)

	// PostEpisodesWithBodyWithResponse request with any body
	PostEpisodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEpisodesResponse, error)

	PostEpisodesWithResponse(ctx context.Context, body PostEpisodesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEpisodesResponse, error)

	// DeleteEpisodesEpisodeIdWithResponse request
	DeleteEpisodesEpisodeIdWithResponse(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*DeleteEpisodesEpisodeIdResponse, error)

	// GetEpisodesEpisodeIdWithResponse request
	GetEpisodesEpisodeIdWithResponse(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*GetEpisodesEpisodeIdResponse, error)

	// PatchEpisodesEpisodeIdWithBodyWithResponse request with any body
	PatchEpisodesEpisodeIdWithBodyWithResponse(ctx context.Context, episodeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEpisodesEpisodeIdResponse, error)

	PatchEpisodesEpisodeIdWithResponse(ctx context.Context, episodeId string, body PatchEpisodesEpisodeIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEpisodesEpisodeIdResponse, error)

	// GetFeaturesWithResponse request
	GetFeaturesWithResponse(ctx context.Context, params *GetFeaturesParams, reqEditors ...RequestEditorFn) (*GetFeaturesResponse, error)

	// PostImagesWithBodyWithResponse request with any body
	PostImagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostImagesResponse, error)

	// PostInitializeWithResponse request
	PostInitializeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostInitializeResponse, error)

	// GetRankingsWithResponse request
	GetRankingsWithResponse(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*GetRankingsResponse, error)

	// GetReleasesWithResponse request
	GetReleasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReleasesResponse, error)

	// GetReleasesDayOfWeekWithResponse request
	GetReleasesDayOfWeekWithResponse(ctx context.Context, dayOfWeek string, reqEditors ...RequestEditorFn) (*GetReleasesDayOfWeekResponse, error)
}

type PostAdminLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description string `json:"description"`
		Id          string `json:"id"`
		Image       Image  `json:"image"`
	}
}

// Status returns HTTPResponse.Status
func (r PostAdminLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAdminLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAdminLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostAdminLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAdminLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdminMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Description string `json:"description"`
		Id          string `json:"id"`
		Image       Image  `json:"image"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAdminMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdminMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetAuthorListItem
}

// Status returns HTTPResponse.Status
func (r GetAuthorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Books []struct {
			Description string `json:"description"`
			Episodes    []struct {
				Chapter     float32 `json:"chapter"`
				Description string  `json:"description"`
				Id          string  `json:"id"`
				Name        string  `json:"name"`
			} `json:"episodes"`
			Id    string `json:"id"`
			Image Image  `json:"image"`
			Name  string `json:"name"`
		} `json:"books"`
		Description string `json:"description"`
		Id          string `json:"id"`
		Image       Image  `json:"image"`
		Name        string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r PostAuthorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorsAuthorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorsAuthorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorsAuthorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorsAuthorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAuthorDetail
}

// Status returns HTTPResponse.Status
func (r GetAuthorsAuthorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorsAuthorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAuthorsAuthorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Books []struct {
			Description string `json:"description"`
			Episodes    []struct {
				Chapter     float32 `json:"chapter"`
				Description string  `json:"description"`
				Id          string  `json:"id"`
				Name        string  `json:"name"`
			} `json:"episodes"`
			Id    string `json:"id"`
			Image Image  `json:"image"`
			Name  string `json:"name"`
		} `json:"books"`
		Description string `json:"description"`
		Id          string `json:"id"`
		Image       Image  `json:"image"`
		Name        string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchAuthorsAuthorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAuthorsAuthorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Author struct {
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
		} `json:"author"`
		Description string `json:"description"`
		Episodes    []struct {
			Id string `json:"id"`
		} `json:"episodes"`
		Id       string `json:"id"`
		Image    Image  `json:"image"`
		Name     string `json:"name"`
		NameRuby string `json:"nameRuby"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Author struct {
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
		} `json:"author"`
		Description string `json:"description"`
		Episodes    []struct {
			Id string `json:"id"`
		} `json:"episodes"`
		Id       string `json:"id"`
		Image    Image  `json:"image"`
		Name     string `json:"name"`
		NameRuby string `json:"nameRuby"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBooksBookIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteBooksBookIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBooksBookIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBooksBookIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBooksDetail
}

// Status returns HTTPResponse.Status
func (r GetBooksBookIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBooksBookIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchBooksBookIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Author struct {
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
		} `json:"author"`
		Description string `json:"description"`
		Episodes    []struct {
			Id string `json:"id"`
		} `json:"episodes"`
		Id       string `json:"id"`
		Image    Image  `json:"image"`
		Name     string `json:"name"`
		NameRuby string `json:"nameRuby"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchBooksBookIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchBooksBookIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodePagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Id    string  `json:"id"`
		Image Image   `json:"image"`
		Page  float32 `json:"page"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEpisodePagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodePagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEpisodePagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id    string  `json:"id"`
		Image Image   `json:"image"`
		Page  float32 `json:"page"`
	}
}

// Status returns HTTPResponse.Status
func (r PostEpisodePagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEpisodePagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEpisodePagesEpisodePageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteEpisodePagesEpisodePageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEpisodePagesEpisodePageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchEpisodePagesEpisodePageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id    string  `json:"id"`
		Image Image   `json:"image"`
		Page  float32 `json:"page"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchEpisodePagesEpisodePageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchEpisodePagesEpisodePageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodePagesPageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id    string  `json:"id"`
		Image Image   `json:"image"`
		Page  float32 `json:"page"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEpisodePagesPageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodePagesPageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Book struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
			NameRuby    string `json:"nameRuby"`
		} `json:"book"`
		Chapter     float32 `json:"chapter"`
		Description string  `json:"description"`
		Id          string  `json:"id"`
		Image       Image   `json:"image"`
		Name        string  `json:"name"`
		NameRuby    string  `json:"nameRuby"`
		Pages       []struct {
			Id    string  `json:"id"`
			Image Image   `json:"image"`
			Page  float32 `json:"page"`
		} `json:"pages"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Book struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
			NameRuby    string `json:"nameRuby"`
		} `json:"book"`
		Chapter     float32 `json:"chapter"`
		Description string  `json:"description"`
		Id          string  `json:"id"`
		Image       Image   `json:"image"`
		Name        string  `json:"name"`
		NameRuby    string  `json:"nameRuby"`
		Pages       []struct {
			Id    string  `json:"id"`
			Image Image   `json:"image"`
			Page  float32 `json:"page"`
		} `json:"pages"`
	}
}

// Status returns HTTPResponse.Status
func (r PostEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEpisodesEpisodeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteEpisodesEpisodeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEpisodesEpisodeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEpisodesEpisodeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEpisodes
}

// Status returns HTTPResponse.Status
func (r GetEpisodesEpisodeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEpisodesEpisodeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchEpisodesEpisodeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Book struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
			NameRuby    string `json:"nameRuby"`
		} `json:"book"`
		Chapter     float32 `json:"chapter"`
		Description string  `json:"description"`
		Id          string  `json:"id"`
		Image       Image   `json:"image"`
		Name        string  `json:"name"`
		NameRuby    string  `json:"nameRuby"`
		Pages       []struct {
			Id    string  `json:"id"`
			Image Image   `json:"image"`
			Page  float32 `json:"page"`
		} `json:"pages"`
	}
}

// Status returns HTTPResponse.Status
func (r PatchEpisodesEpisodeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchEpisodesEpisodeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Book struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
		} `json:"book"`
		Id string `json:"id"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Alt string `json:"alt"`
		Id  string `json:"id"`
	}
}

// Status returns HTTPResponse.Status
func (r PostImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInitializeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostInitializeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInitializeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRankingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetRankingsItem
}

// Status returns HTTPResponse.Status
func (r GetRankingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRankingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		DayOfWeek string `json:"dayOfWeek"`
		Id        string `json:"id"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleasesDayOfWeekResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Books []struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Id    string `json:"id"`
			Image Image  `json:"image"`
			Name  string `json:"name"`
		} `json:"books"`
		DayOfWeek string `json:"dayOfWeek"`
		Id        string `json:"id"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReleasesDayOfWeekResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleasesDayOfWeekResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAdminLoginWithBodyWithResponse request with arbitrary body returning *PostAdminLoginResponse
func (c *ClientWithResponses) PostAdminLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAdminLoginResponse, error) {
	rsp, err := c.PostAdminLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdminLoginResponse(rsp)
}

func (c *ClientWithResponses) PostAdminLoginWithResponse(ctx context.Context, body PostAdminLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAdminLoginResponse, error) {
	rsp, err := c.PostAdminLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdminLoginResponse(rsp)
}

// PostAdminLogoutWithResponse request returning *PostAdminLogoutResponse
func (c *ClientWithResponses) PostAdminLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAdminLogoutResponse, error) {
	rsp, err := c.PostAdminLogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdminLogoutResponse(rsp)
}

// GetAdminMeWithResponse request returning *GetAdminMeResponse
func (c *ClientWithResponses) GetAdminMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAdminMeResponse, error) {
	rsp, err := c.GetAdminMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdminMeResponse(rsp)
}

// GetAuthorsWithResponse request returning *GetAuthorsResponse
func (c *ClientWithResponses) GetAuthorsWithResponse(ctx context.Context, params *GetAuthorsParams, reqEditors ...RequestEditorFn) (*GetAuthorsResponse, error) {
	rsp, err := c.GetAuthors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorsResponse(rsp)
}

// PostAuthorsWithBodyWithResponse request with arbitrary body returning *PostAuthorsResponse
func (c *ClientWithResponses) PostAuthorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorsResponse, error) {
	rsp, err := c.PostAuthorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorsResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorsWithResponse(ctx context.Context, body PostAuthorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorsResponse, error) {
	rsp, err := c.PostAuthors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorsResponse(rsp)
}

// DeleteAuthorsAuthorIdWithResponse request returning *DeleteAuthorsAuthorIdResponse
func (c *ClientWithResponses) DeleteAuthorsAuthorIdWithResponse(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*DeleteAuthorsAuthorIdResponse, error) {
	rsp, err := c.DeleteAuthorsAuthorId(ctx, authorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorsAuthorIdResponse(rsp)
}

// GetAuthorsAuthorIdWithResponse request returning *GetAuthorsAuthorIdResponse
func (c *ClientWithResponses) GetAuthorsAuthorIdWithResponse(ctx context.Context, authorId string, reqEditors ...RequestEditorFn) (*GetAuthorsAuthorIdResponse, error) {
	rsp, err := c.GetAuthorsAuthorId(ctx, authorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorsAuthorIdResponse(rsp)
}

// PatchAuthorsAuthorIdWithBodyWithResponse request with arbitrary body returning *PatchAuthorsAuthorIdResponse
func (c *ClientWithResponses) PatchAuthorsAuthorIdWithBodyWithResponse(ctx context.Context, authorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAuthorsAuthorIdResponse, error) {
	rsp, err := c.PatchAuthorsAuthorIdWithBody(ctx, authorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAuthorsAuthorIdResponse(rsp)
}

func (c *ClientWithResponses) PatchAuthorsAuthorIdWithResponse(ctx context.Context, authorId string, body PatchAuthorsAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAuthorsAuthorIdResponse, error) {
	rsp, err := c.PatchAuthorsAuthorId(ctx, authorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAuthorsAuthorIdResponse(rsp)
}

// GetBooksWithResponse request returning *GetBooksResponse
func (c *ClientWithResponses) GetBooksWithResponse(ctx context.Context, params *GetBooksParams, reqEditors ...RequestEditorFn) (*GetBooksResponse, error) {
	rsp, err := c.GetBooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBooksResponse(rsp)
}

// PostBooksWithBodyWithResponse request with arbitrary body returning *PostBooksResponse
func (c *ClientWithResponses) PostBooksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBooksResponse, error) {
	rsp, err := c.PostBooksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBooksResponse(rsp)
}

func (c *ClientWithResponses) PostBooksWithResponse(ctx context.Context, body PostBooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBooksResponse, error) {
	rsp, err := c.PostBooks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBooksResponse(rsp)
}

// DeleteBooksBookIdWithResponse request returning *DeleteBooksBookIdResponse
func (c *ClientWithResponses) DeleteBooksBookIdWithResponse(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*DeleteBooksBookIdResponse, error) {
	rsp, err := c.DeleteBooksBookId(ctx, bookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBooksBookIdResponse(rsp)
}

// GetBooksBookIdWithResponse request returning *GetBooksBookIdResponse
func (c *ClientWithResponses) GetBooksBookIdWithResponse(ctx context.Context, bookId string, reqEditors ...RequestEditorFn) (*GetBooksBookIdResponse, error) {
	rsp, err := c.GetBooksBookId(ctx, bookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBooksBookIdResponse(rsp)
}

// PatchBooksBookIdWithBodyWithResponse request with arbitrary body returning *PatchBooksBookIdResponse
func (c *ClientWithResponses) PatchBooksBookIdWithBodyWithResponse(ctx context.Context, bookId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBooksBookIdResponse, error) {
	rsp, err := c.PatchBooksBookIdWithBody(ctx, bookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBooksBookIdResponse(rsp)
}

func (c *ClientWithResponses) PatchBooksBookIdWithResponse(ctx context.Context, bookId string, body PatchBooksBookIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBooksBookIdResponse, error) {
	rsp, err := c.PatchBooksBookId(ctx, bookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBooksBookIdResponse(rsp)
}

// GetEpisodePagesWithResponse request returning *GetEpisodePagesResponse
func (c *ClientWithResponses) GetEpisodePagesWithResponse(ctx context.Context, params *GetEpisodePagesParams, reqEditors ...RequestEditorFn) (*GetEpisodePagesResponse, error) {
	rsp, err := c.GetEpisodePages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodePagesResponse(rsp)
}

// PostEpisodePagesWithBodyWithResponse request with arbitrary body returning *PostEpisodePagesResponse
func (c *ClientWithResponses) PostEpisodePagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEpisodePagesResponse, error) {
	rsp, err := c.PostEpisodePagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEpisodePagesResponse(rsp)
}

func (c *ClientWithResponses) PostEpisodePagesWithResponse(ctx context.Context, body PostEpisodePagesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEpisodePagesResponse, error) {
	rsp, err := c.PostEpisodePages(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEpisodePagesResponse(rsp)
}

// DeleteEpisodePagesEpisodePageIdWithResponse request returning *DeleteEpisodePagesEpisodePageIdResponse
func (c *ClientWithResponses) DeleteEpisodePagesEpisodePageIdWithResponse(ctx context.Context, episodePageId string, reqEditors ...RequestEditorFn) (*DeleteEpisodePagesEpisodePageIdResponse, error) {
	rsp, err := c.DeleteEpisodePagesEpisodePageId(ctx, episodePageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEpisodePagesEpisodePageIdResponse(rsp)
}

// PatchEpisodePagesEpisodePageIdWithBodyWithResponse request with arbitrary body returning *PatchEpisodePagesEpisodePageIdResponse
func (c *ClientWithResponses) PatchEpisodePagesEpisodePageIdWithBodyWithResponse(ctx context.Context, episodePageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEpisodePagesEpisodePageIdResponse, error) {
	rsp, err := c.PatchEpisodePagesEpisodePageIdWithBody(ctx, episodePageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEpisodePagesEpisodePageIdResponse(rsp)
}

func (c *ClientWithResponses) PatchEpisodePagesEpisodePageIdWithResponse(ctx context.Context, episodePageId string, body PatchEpisodePagesEpisodePageIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEpisodePagesEpisodePageIdResponse, error) {
	rsp, err := c.PatchEpisodePagesEpisodePageId(ctx, episodePageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEpisodePagesEpisodePageIdResponse(rsp)
}

// GetEpisodePagesPageIdWithResponse request returning *GetEpisodePagesPageIdResponse
func (c *ClientWithResponses) GetEpisodePagesPageIdWithResponse(ctx context.Context, pageId string, reqEditors ...RequestEditorFn) (*GetEpisodePagesPageIdResponse, error) {
	rsp, err := c.GetEpisodePagesPageId(ctx, pageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodePagesPageIdResponse(rsp)
}

// GetEpisodesWithResponse request returning *GetEpisodesResponse
func (c *ClientWithResponses) GetEpisodesWithResponse(ctx context.Context, params *GetEpisodesParams, reqEditors ...RequestEditorFn) (*GetEpisodesResponse, error) {
	rsp, err := c.GetEpisodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodesResponse(rsp)
}

// PostEpisodesWithBodyWithResponse request with arbitrary body returning *PostEpisodesResponse
func (c *ClientWithResponses) PostEpisodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEpisodesResponse, error) {
	rsp, err := c.PostEpisodesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEpisodesResponse(rsp)
}

func (c *ClientWithResponses) PostEpisodesWithResponse(ctx context.Context, body PostEpisodesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEpisodesResponse, error) {
	rsp, err := c.PostEpisodes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEpisodesResponse(rsp)
}

// DeleteEpisodesEpisodeIdWithResponse request returning *DeleteEpisodesEpisodeIdResponse
func (c *ClientWithResponses) DeleteEpisodesEpisodeIdWithResponse(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*DeleteEpisodesEpisodeIdResponse, error) {
	rsp, err := c.DeleteEpisodesEpisodeId(ctx, episodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEpisodesEpisodeIdResponse(rsp)
}

// GetEpisodesEpisodeIdWithResponse request returning *GetEpisodesEpisodeIdResponse
func (c *ClientWithResponses) GetEpisodesEpisodeIdWithResponse(ctx context.Context, episodeId string, reqEditors ...RequestEditorFn) (*GetEpisodesEpisodeIdResponse, error) {
	rsp, err := c.GetEpisodesEpisodeId(ctx, episodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEpisodesEpisodeIdResponse(rsp)
}

// PatchEpisodesEpisodeIdWithBodyWithResponse request with arbitrary body returning *PatchEpisodesEpisodeIdResponse
func (c *ClientWithResponses) PatchEpisodesEpisodeIdWithBodyWithResponse(ctx context.Context, episodeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEpisodesEpisodeIdResponse, error) {
	rsp, err := c.PatchEpisodesEpisodeIdWithBody(ctx, episodeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEpisodesEpisodeIdResponse(rsp)
}

func (c *ClientWithResponses) PatchEpisodesEpisodeIdWithResponse(ctx context.Context, episodeId string, body PatchEpisodesEpisodeIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEpisodesEpisodeIdResponse, error) {
	rsp, err := c.PatchEpisodesEpisodeId(ctx, episodeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEpisodesEpisodeIdResponse(rsp)
}

// GetFeaturesWithResponse request returning *GetFeaturesResponse
func (c *ClientWithResponses) GetFeaturesWithResponse(ctx context.Context, params *GetFeaturesParams, reqEditors ...RequestEditorFn) (*GetFeaturesResponse, error) {
	rsp, err := c.GetFeatures(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeaturesResponse(rsp)
}

// PostImagesWithBodyWithResponse request with arbitrary body returning *PostImagesResponse
func (c *ClientWithResponses) PostImagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostImagesResponse, error) {
	rsp, err := c.PostImagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostImagesResponse(rsp)
}

// PostInitializeWithResponse request returning *PostInitializeResponse
func (c *ClientWithResponses) PostInitializeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostInitializeResponse, error) {
	rsp, err := c.PostInitialize(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInitializeResponse(rsp)
}

// GetRankingsWithResponse request returning *GetRankingsResponse
func (c *ClientWithResponses) GetRankingsWithResponse(ctx context.Context, params *GetRankingsParams, reqEditors ...RequestEditorFn) (*GetRankingsResponse, error) {
	rsp, err := c.GetRankings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRankingsResponse(rsp)
}

// GetReleasesWithResponse request returning *GetReleasesResponse
func (c *ClientWithResponses) GetReleasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReleasesResponse, error) {
	rsp, err := c.GetReleases(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReleasesResponse(rsp)
}

// GetReleasesDayOfWeekWithResponse request returning *GetReleasesDayOfWeekResponse
func (c *ClientWithResponses) GetReleasesDayOfWeekWithResponse(ctx context.Context, dayOfWeek string, reqEditors ...RequestEditorFn) (*GetReleasesDayOfWeekResponse, error) {
	rsp, err := c.GetReleasesDayOfWeek(ctx, dayOfWeek, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReleasesDayOfWeekResponse(rsp)
}

// ParsePostAdminLoginResponse parses an HTTP response from a PostAdminLoginWithResponse call
func ParsePostAdminLoginResponse(rsp *http.Response) (*PostAdminLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAdminLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAdminLogoutResponse parses an HTTP response from a PostAdminLogoutWithResponse call
func ParsePostAdminLogoutResponse(rsp *http.Response) (*PostAdminLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAdminLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAdminMeResponse parses an HTTP response from a GetAdminMeWithResponse call
func ParseGetAdminMeResponse(rsp *http.Response) (*GetAdminMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdminMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuthorsResponse parses an HTTP response from a GetAuthorsWithResponse call
func ParseGetAuthorsResponse(rsp *http.Response) (*GetAuthorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetAuthorListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAuthorsResponse parses an HTTP response from a PostAuthorsWithResponse call
func ParsePostAuthorsResponse(rsp *http.Response) (*PostAuthorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Books []struct {
				Description string `json:"description"`
				Episodes    []struct {
					Chapter     float32 `json:"chapter"`
					Description string  `json:"description"`
					Id          string  `json:"id"`
					Name        string  `json:"name"`
				} `json:"episodes"`
				Id    string `json:"id"`
				Image Image  `json:"image"`
				Name  string `json:"name"`
			} `json:"books"`
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorsAuthorIdResponse parses an HTTP response from a DeleteAuthorsAuthorIdWithResponse call
func ParseDeleteAuthorsAuthorIdResponse(rsp *http.Response) (*DeleteAuthorsAuthorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorsAuthorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAuthorsAuthorIdResponse parses an HTTP response from a GetAuthorsAuthorIdWithResponse call
func ParseGetAuthorsAuthorIdResponse(rsp *http.Response) (*GetAuthorsAuthorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorsAuthorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAuthorDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchAuthorsAuthorIdResponse parses an HTTP response from a PatchAuthorsAuthorIdWithResponse call
func ParsePatchAuthorsAuthorIdResponse(rsp *http.Response) (*PatchAuthorsAuthorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAuthorsAuthorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Books []struct {
				Description string `json:"description"`
				Episodes    []struct {
					Chapter     float32 `json:"chapter"`
					Description string  `json:"description"`
					Id          string  `json:"id"`
					Name        string  `json:"name"`
				} `json:"episodes"`
				Id    string `json:"id"`
				Image Image  `json:"image"`
				Name  string `json:"name"`
			} `json:"books"`
			Description string `json:"description"`
			Id          string `json:"id"`
			Image       Image  `json:"image"`
			Name        string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBooksResponse parses an HTTP response from a GetBooksWithResponse call
func ParseGetBooksResponse(rsp *http.Response) (*GetBooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Description string `json:"description"`
			Episodes    []struct {
				Id string `json:"id"`
			} `json:"episodes"`
			Id       string `json:"id"`
			Image    Image  `json:"image"`
			Name     string `json:"name"`
			NameRuby string `json:"nameRuby"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostBooksResponse parses an HTTP response from a PostBooksWithResponse call
func ParsePostBooksResponse(rsp *http.Response) (*PostBooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Description string `json:"description"`
			Episodes    []struct {
				Id string `json:"id"`
			} `json:"episodes"`
			Id       string `json:"id"`
			Image    Image  `json:"image"`
			Name     string `json:"name"`
			NameRuby string `json:"nameRuby"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBooksBookIdResponse parses an HTTP response from a DeleteBooksBookIdWithResponse call
func ParseDeleteBooksBookIdResponse(rsp *http.Response) (*DeleteBooksBookIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBooksBookIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBooksBookIdResponse parses an HTTP response from a GetBooksBookIdWithResponse call
func ParseGetBooksBookIdResponse(rsp *http.Response) (*GetBooksBookIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBooksBookIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBooksDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchBooksBookIdResponse parses an HTTP response from a PatchBooksBookIdWithResponse call
func ParsePatchBooksBookIdResponse(rsp *http.Response) (*PatchBooksBookIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchBooksBookIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Author struct {
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"author"`
			Description string `json:"description"`
			Episodes    []struct {
				Id string `json:"id"`
			} `json:"episodes"`
			Id       string `json:"id"`
			Image    Image  `json:"image"`
			Name     string `json:"name"`
			NameRuby string `json:"nameRuby"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEpisodePagesResponse parses an HTTP response from a GetEpisodePagesWithResponse call
func ParseGetEpisodePagesResponse(rsp *http.Response) (*GetEpisodePagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodePagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Id    string  `json:"id"`
			Image Image   `json:"image"`
			Page  float32 `json:"page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostEpisodePagesResponse parses an HTTP response from a PostEpisodePagesWithResponse call
func ParsePostEpisodePagesResponse(rsp *http.Response) (*PostEpisodePagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEpisodePagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id    string  `json:"id"`
			Image Image   `json:"image"`
			Page  float32 `json:"page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEpisodePagesEpisodePageIdResponse parses an HTTP response from a DeleteEpisodePagesEpisodePageIdWithResponse call
func ParseDeleteEpisodePagesEpisodePageIdResponse(rsp *http.Response) (*DeleteEpisodePagesEpisodePageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEpisodePagesEpisodePageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchEpisodePagesEpisodePageIdResponse parses an HTTP response from a PatchEpisodePagesEpisodePageIdWithResponse call
func ParsePatchEpisodePagesEpisodePageIdResponse(rsp *http.Response) (*PatchEpisodePagesEpisodePageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchEpisodePagesEpisodePageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id    string  `json:"id"`
			Image Image   `json:"image"`
			Page  float32 `json:"page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEpisodePagesPageIdResponse parses an HTTP response from a GetEpisodePagesPageIdWithResponse call
func ParseGetEpisodePagesPageIdResponse(rsp *http.Response) (*GetEpisodePagesPageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodePagesPageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id    string  `json:"id"`
			Image Image   `json:"image"`
			Page  float32 `json:"page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEpisodesResponse parses an HTTP response from a GetEpisodesWithResponse call
func ParseGetEpisodesResponse(rsp *http.Response) (*GetEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Book struct {
				Author struct {
					Description string `json:"description"`
					Id          string `json:"id"`
					Image       Image  `json:"image"`
					Name        string `json:"name"`
				} `json:"author"`
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
				NameRuby    string `json:"nameRuby"`
			} `json:"book"`
			Chapter     float32 `json:"chapter"`
			Description string  `json:"description"`
			Id          string  `json:"id"`
			Image       Image   `json:"image"`
			Name        string  `json:"name"`
			NameRuby    string  `json:"nameRuby"`
			Pages       []struct {
				Id    string  `json:"id"`
				Image Image   `json:"image"`
				Page  float32 `json:"page"`
			} `json:"pages"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostEpisodesResponse parses an HTTP response from a PostEpisodesWithResponse call
func ParsePostEpisodesResponse(rsp *http.Response) (*PostEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Book struct {
				Author struct {
					Description string `json:"description"`
					Id          string `json:"id"`
					Image       Image  `json:"image"`
					Name        string `json:"name"`
				} `json:"author"`
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
				NameRuby    string `json:"nameRuby"`
			} `json:"book"`
			Chapter     float32 `json:"chapter"`
			Description string  `json:"description"`
			Id          string  `json:"id"`
			Image       Image   `json:"image"`
			Name        string  `json:"name"`
			NameRuby    string  `json:"nameRuby"`
			Pages       []struct {
				Id    string  `json:"id"`
				Image Image   `json:"image"`
				Page  float32 `json:"page"`
			} `json:"pages"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEpisodesEpisodeIdResponse parses an HTTP response from a DeleteEpisodesEpisodeIdWithResponse call
func ParseDeleteEpisodesEpisodeIdResponse(rsp *http.Response) (*DeleteEpisodesEpisodeIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEpisodesEpisodeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEpisodesEpisodeIdResponse parses an HTTP response from a GetEpisodesEpisodeIdWithResponse call
func ParseGetEpisodesEpisodeIdResponse(rsp *http.Response) (*GetEpisodesEpisodeIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEpisodesEpisodeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEpisodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchEpisodesEpisodeIdResponse parses an HTTP response from a PatchEpisodesEpisodeIdWithResponse call
func ParsePatchEpisodesEpisodeIdResponse(rsp *http.Response) (*PatchEpisodesEpisodeIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchEpisodesEpisodeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Book struct {
				Author struct {
					Description string `json:"description"`
					Id          string `json:"id"`
					Image       Image  `json:"image"`
					Name        string `json:"name"`
				} `json:"author"`
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
				NameRuby    string `json:"nameRuby"`
			} `json:"book"`
			Chapter     float32 `json:"chapter"`
			Description string  `json:"description"`
			Id          string  `json:"id"`
			Image       Image   `json:"image"`
			Name        string  `json:"name"`
			NameRuby    string  `json:"nameRuby"`
			Pages       []struct {
				Id    string  `json:"id"`
				Image Image   `json:"image"`
				Page  float32 `json:"page"`
			} `json:"pages"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFeaturesResponse parses an HTTP response from a GetFeaturesWithResponse call
func ParseGetFeaturesResponse(rsp *http.Response) (*GetFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Book struct {
				Author struct {
					Description string `json:"description"`
					Id          string `json:"id"`
					Image       Image  `json:"image"`
					Name        string `json:"name"`
				} `json:"author"`
				Description string `json:"description"`
				Id          string `json:"id"`
				Image       Image  `json:"image"`
				Name        string `json:"name"`
			} `json:"book"`
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostImagesResponse parses an HTTP response from a PostImagesWithResponse call
func ParsePostImagesResponse(rsp *http.Response) (*PostImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Alt string `json:"alt"`
			Id  string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostInitializeResponse parses an HTTP response from a PostInitializeWithResponse call
func ParsePostInitializeResponse(rsp *http.Response) (*PostInitializeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInitializeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRankingsResponse parses an HTTP response from a GetRankingsWithResponse call
func ParseGetRankingsResponse(rsp *http.Response) (*GetRankingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRankingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetRankingsItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReleasesResponse parses an HTTP response from a GetReleasesWithResponse call
func ParseGetReleasesResponse(rsp *http.Response) (*GetReleasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			DayOfWeek string `json:"dayOfWeek"`
			Id        string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReleasesDayOfWeekResponse parses an HTTP response from a GetReleasesDayOfWeekWithResponse call
func ParseGetReleasesDayOfWeekResponse(rsp *http.Response) (*GetReleasesDayOfWeekResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReleasesDayOfWeekResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Books []struct {
				Author struct {
					Description string `json:"description"`
					Id          string `json:"id"`
					Image       Image  `json:"image"`
					Name        string `json:"name"`
				} `json:"author"`
				Id    string `json:"id"`
				Image Image  `json:"image"`
				Name  string `json:"name"`
			} `json:"books"`
			DayOfWeek string `json:"dayOfWeek"`
			Id        string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /admin/login)
	PostAdminLogin(ctx echo.Context) error

	// (POST /admin/logout)
	PostAdminLogout(ctx echo.Context) error

	// (GET /admin/me)
	GetAdminMe(ctx echo.Context) error

	// (GET /authors)
	GetAuthors(ctx echo.Context, params GetAuthorsParams) error

	// (POST /authors)
	PostAuthors(ctx echo.Context) error

	// (DELETE /authors/{authorId})
	DeleteAuthorsAuthorId(ctx echo.Context, authorId string) error

	// (GET /authors/{authorId})
	GetAuthorsAuthorId(ctx echo.Context, authorId string) error

	// (PATCH /authors/{authorId})
	PatchAuthorsAuthorId(ctx echo.Context, authorId string) error

	// (GET /books)
	GetBooks(ctx echo.Context, params GetBooksParams) error

	// (POST /books)
	PostBooks(ctx echo.Context) error

	// (DELETE /books/{bookId})
	DeleteBooksBookId(ctx echo.Context, bookId string) error

	// (GET /books/{bookId})
	GetBooksBookId(ctx echo.Context, bookId string) error

	// (PATCH /books/{bookId})
	PatchBooksBookId(ctx echo.Context, bookId string) error

	// (GET /episodePages)
	GetEpisodePages(ctx echo.Context, params GetEpisodePagesParams) error

	// (POST /episodePages)
	PostEpisodePages(ctx echo.Context) error

	// (DELETE /episodePages/{episodePageId})
	DeleteEpisodePagesEpisodePageId(ctx echo.Context, episodePageId string) error

	// (PATCH /episodePages/{episodePageId})
	PatchEpisodePagesEpisodePageId(ctx echo.Context, episodePageId string) error

	// (GET /episodePages/{pageId})
	GetEpisodePagesPageId(ctx echo.Context, pageId string) error

	// (GET /episodes)
	GetEpisodes(ctx echo.Context, params GetEpisodesParams) error

	// (POST /episodes)
	PostEpisodes(ctx echo.Context) error

	// (DELETE /episodes/{episodeId})
	DeleteEpisodesEpisodeId(ctx echo.Context, episodeId string) error

	// (GET /episodes/{episodeId})
	GetEpisodesEpisodeId(ctx echo.Context, episodeId string) error

	// (PATCH /episodes/{episodeId})
	PatchEpisodesEpisodeId(ctx echo.Context, episodeId string) error

	// (GET /features)
	GetFeatures(ctx echo.Context, params GetFeaturesParams) error

	// (POST /images)
	PostImages(ctx echo.Context) error

	// (POST /initialize)
	PostInitialize(ctx echo.Context) error

	// (GET /rankings)
	GetRankings(ctx echo.Context, params GetRankingsParams) error

	// (GET /releases)
	GetReleases(ctx echo.Context) error

	// (GET /releases/{dayOfWeek})
	GetReleasesDayOfWeek(ctx echo.Context, dayOfWeek string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostAdminLogin converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdminLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdminLogin(ctx)
	return err
}

// PostAdminLogout converts echo context to params.
func (w *ServerInterfaceWrapper) PostAdminLogout(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAdminLogout(ctx)
	return err
}

// GetAdminMe converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdminMe(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAdminMe(ctx)
	return err
}

// GetAuthors converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthors(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAuthorsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthors(ctx, params)
	return err
}

// PostAuthors converts echo context to params.
func (w *ServerInterfaceWrapper) PostAuthors(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAuthors(ctx)
	return err
}

// DeleteAuthorsAuthorId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAuthorsAuthorId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "authorId" -------------
	var authorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorId", runtime.ParamLocationPath, ctx.Param("authorId"), &authorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAuthorsAuthorId(ctx, authorId)
	return err
}

// GetAuthorsAuthorId converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuthorsAuthorId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "authorId" -------------
	var authorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorId", runtime.ParamLocationPath, ctx.Param("authorId"), &authorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAuthorsAuthorId(ctx, authorId)
	return err
}

// PatchAuthorsAuthorId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAuthorsAuthorId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "authorId" -------------
	var authorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "authorId", runtime.ParamLocationPath, ctx.Param("authorId"), &authorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAuthorsAuthorId(ctx, authorId)
	return err
}

// GetBooks converts echo context to params.
func (w *ServerInterfaceWrapper) GetBooks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBooksParams
	// ------------- Optional query parameter "authorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorId", ctx.QueryParams(), &params.AuthorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorId: %s", err))
	}

	// ------------- Optional query parameter "authorName" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorName", ctx.QueryParams(), &params.AuthorName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorName: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBooks(ctx, params)
	return err
}

// PostBooks converts echo context to params.
func (w *ServerInterfaceWrapper) PostBooks(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostBooks(ctx)
	return err
}

// DeleteBooksBookId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteBooksBookId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bookId" -------------
	var bookId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bookId", runtime.ParamLocationPath, ctx.Param("bookId"), &bookId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bookId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteBooksBookId(ctx, bookId)
	return err
}

// GetBooksBookId converts echo context to params.
func (w *ServerInterfaceWrapper) GetBooksBookId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bookId" -------------
	var bookId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bookId", runtime.ParamLocationPath, ctx.Param("bookId"), &bookId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bookId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBooksBookId(ctx, bookId)
	return err
}

// PatchBooksBookId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchBooksBookId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "bookId" -------------
	var bookId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "bookId", runtime.ParamLocationPath, ctx.Param("bookId"), &bookId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bookId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchBooksBookId(ctx, bookId)
	return err
}

// GetEpisodePages converts echo context to params.
func (w *ServerInterfaceWrapper) GetEpisodePages(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEpisodePagesParams
	// ------------- Required query parameter "episodeId" -------------

	err = runtime.BindQueryParameter("form", true, true, "episodeId", ctx.QueryParams(), &params.EpisodeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter episodeId: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEpisodePages(ctx, params)
	return err
}

// PostEpisodePages converts echo context to params.
func (w *ServerInterfaceWrapper) PostEpisodePages(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEpisodePages(ctx)
	return err
}

// DeleteEpisodePagesEpisodePageId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEpisodePagesEpisodePageId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "episodePageId" -------------
	var episodePageId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "episodePageId", runtime.ParamLocationPath, ctx.Param("episodePageId"), &episodePageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter episodePageId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEpisodePagesEpisodePageId(ctx, episodePageId)
	return err
}

// PatchEpisodePagesEpisodePageId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEpisodePagesEpisodePageId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "episodePageId" -------------
	var episodePageId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "episodePageId", runtime.ParamLocationPath, ctx.Param("episodePageId"), &episodePageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter episodePageId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEpisodePagesEpisodePageId(ctx, episodePageId)
	return err
}

// GetEpisodePagesPageId converts echo context to params.
func (w *ServerInterfaceWrapper) GetEpisodePagesPageId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "pageId" -------------
	var pageId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "pageId", runtime.ParamLocationPath, ctx.Param("pageId"), &pageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEpisodePagesPageId(ctx, pageId)
	return err
}

// GetEpisodes converts echo context to params.
func (w *ServerInterfaceWrapper) GetEpisodes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEpisodesParams
	// ------------- Required query parameter "bookId" -------------

	err = runtime.BindQueryParameter("form", true, true, "bookId", ctx.QueryParams(), &params.BookId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bookId: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEpisodes(ctx, params)
	return err
}

// PostEpisodes converts echo context to params.
func (w *ServerInterfaceWrapper) PostEpisodes(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEpisodes(ctx)
	return err
}

// DeleteEpisodesEpisodeId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEpisodesEpisodeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "episodeId" -------------
	var episodeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "episodeId", runtime.ParamLocationPath, ctx.Param("episodeId"), &episodeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter episodeId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEpisodesEpisodeId(ctx, episodeId)
	return err
}

// GetEpisodesEpisodeId converts echo context to params.
func (w *ServerInterfaceWrapper) GetEpisodesEpisodeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "episodeId" -------------
	var episodeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "episodeId", runtime.ParamLocationPath, ctx.Param("episodeId"), &episodeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter episodeId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEpisodesEpisodeId(ctx, episodeId)
	return err
}

// PatchEpisodesEpisodeId converts echo context to params.
func (w *ServerInterfaceWrapper) PatchEpisodesEpisodeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "episodeId" -------------
	var episodeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "episodeId", runtime.ParamLocationPath, ctx.Param("episodeId"), &episodeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter episodeId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchEpisodesEpisodeId(ctx, episodeId)
	return err
}

// GetFeatures converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeatures(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFeaturesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeatures(ctx, params)
	return err
}

// PostImages converts echo context to params.
func (w *ServerInterfaceWrapper) PostImages(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostImages(ctx)
	return err
}

// PostInitialize converts echo context to params.
func (w *ServerInterfaceWrapper) PostInitialize(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostInitialize(ctx)
	return err
}

// GetRankings converts echo context to params.
func (w *ServerInterfaceWrapper) GetRankings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRankingsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRankings(ctx, params)
	return err
}

// GetReleases converts echo context to params.
func (w *ServerInterfaceWrapper) GetReleases(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReleases(ctx)
	return err
}

// GetReleasesDayOfWeek converts echo context to params.
func (w *ServerInterfaceWrapper) GetReleasesDayOfWeek(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dayOfWeek" -------------
	var dayOfWeek string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dayOfWeek", runtime.ParamLocationPath, ctx.Param("dayOfWeek"), &dayOfWeek)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dayOfWeek: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReleasesDayOfWeek(ctx, dayOfWeek)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/admin/login", wrapper.PostAdminLogin)
	router.POST(baseURL+"/admin/logout", wrapper.PostAdminLogout)
	router.GET(baseURL+"/admin/me", wrapper.GetAdminMe)
	router.GET(baseURL+"/authors", wrapper.GetAuthors)
	router.POST(baseURL+"/authors", wrapper.PostAuthors)
	router.DELETE(baseURL+"/authors/:authorId", wrapper.DeleteAuthorsAuthorId)
	router.GET(baseURL+"/authors/:authorId", wrapper.GetAuthorsAuthorId)
	router.PATCH(baseURL+"/authors/:authorId", wrapper.PatchAuthorsAuthorId)
	router.GET(baseURL+"/books", wrapper.GetBooks)
	router.POST(baseURL+"/books", wrapper.PostBooks)
	router.DELETE(baseURL+"/books/:bookId", wrapper.DeleteBooksBookId)
	router.GET(baseURL+"/books/:bookId", wrapper.GetBooksBookId)
	router.PATCH(baseURL+"/books/:bookId", wrapper.PatchBooksBookId)
	router.GET(baseURL+"/episodePages", wrapper.GetEpisodePages)
	router.POST(baseURL+"/episodePages", wrapper.PostEpisodePages)
	router.DELETE(baseURL+"/episodePages/:episodePageId", wrapper.DeleteEpisodePagesEpisodePageId)
	router.PATCH(baseURL+"/episodePages/:episodePageId", wrapper.PatchEpisodePagesEpisodePageId)
	router.GET(baseURL+"/episodePages/:pageId", wrapper.GetEpisodePagesPageId)
	router.GET(baseURL+"/episodes", wrapper.GetEpisodes)
	router.POST(baseURL+"/episodes", wrapper.PostEpisodes)
	router.DELETE(baseURL+"/episodes/:episodeId", wrapper.DeleteEpisodesEpisodeId)
	router.GET(baseURL+"/episodes/:episodeId", wrapper.GetEpisodesEpisodeId)
	router.PATCH(baseURL+"/episodes/:episodeId", wrapper.PatchEpisodesEpisodeId)
	router.GET(baseURL+"/features", wrapper.GetFeatures)
	router.POST(baseURL+"/images", wrapper.PostImages)
	router.POST(baseURL+"/initialize", wrapper.PostInitialize)
	router.GET(baseURL+"/rankings", wrapper.GetRankings)
	router.GET(baseURL+"/releases", wrapper.GetReleases)
	router.GET(baseURL+"/releases/:dayOfWeek", wrapper.GetReleasesDayOfWeek)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xcTW/jNhP+Kwbf96hG2fbmW9KkCwPbNlig6GHhA2PTDjeSqCXpFKnh/16QoixGIqlR",
	"Ist2olNimzMazsczM/zQFi1YmrOMZFKg6RaJxQNJsf73aiMfGL8hEtPkmrFHMZMkVT/knOWES0r0sCUR",
	"C05zSVmmPsrnnKApEpLTbI12EaJL99cpXhP1y/85WaEp+l9cCRIbKeKZHrSLUIZT4mCzixAnPzaUkyWa",
	"fnshin6wISyfNo9KBuz+O1lIxfk2p4ItibjDa+KZYS8zyM1gwybbpPeEN2agZdZDQzJ/JtI2TlPie2Uu",
	"LbokqWiT0W3o3f7BmHP8rD6/0tR+4/ln9oUK6bZGc27d/JEYgwdYLB5wLgl3mOsAOrDNXz448rqyyx3q",
	"ZjqJiNurOeTIPTnYsDMrHLAlPnUc+cITaxc/ENDApgcDxx5iyTmnpjDH9uvih6+b++e3uMaeR1TaGBgI",
	"n4m8tXTZRDy4E701hmpPSSScS01PijbyGfdwGf2YIHI4N/LP9wDZ6vC6KKoceI3SLNMaANE5l75QtA6y",
	"cualdJ5Q/YqzR5qthb9AaZuOzUGlioAtOM4egYWjHmqm4hJ9NnCMN2YZALEu2ipKxLMpGAAx7Jnh+2q2",
	"FAearZjmTWWifru6m01u2EJlxyfChZ4X+nRxeXGpJGE5yXBO0RT9cvHp4lLHpXzQmojxMqVZnLA11arI",
	"mdBerLSFlVCzJZqiOybklRr4RY8rZkCEvGZLjUoLlkmSaUKc5wldaNL4uyj0W6imaQaSmrrOgWpC/MM4",
	"IHIKHhaFS2GaRuQsE8WDf768fIPYA3hPu5OEvOOFgEjb7KJoFPFaKH7ftDHnExUfk6u7GZqrXytfYBsJ",
	"cwY10K3bhgxsIzsIUYTOmjier5pbNeZ3gj6yWT8TOVGQONkIwmGa1Wgogoo1Q1Q8cZwSSdT4b1uk0AH9",
	"2BD+XALUFCU0pcr8lUIbydVNaACuQVeFuJuOrVaChJ84f6NLgKqo5vJKs4ry2ovxSUJFIxbyvLAX48KY",
	"LArF395O/SBxq+8rt5y9ZU2m5uuGn3c5pm/MHpe7xuWuk17uagLGr5xgSQxm+AG+AgwL4+Nt8c9suSu8",
	"OyGSNKHkRn9vuFwZCg/4q5KxgmJcDa7mL/mGhGB9DikVCpk6TDtqy2ZHmxgYq0DJxiyDBlMLKKtguXhw",
	"pBX19bAaO93MNWajMRuN2cjGmL/yZfdstPdzH0JfGzkA3YYFM50bh4L2j1e2He+6zxlmN+TIpxPGDbiB",
	"NuAgTbACBW8LrAEB0ACXwNFPEbHHFpdCD1BhtOzpcJIQLNw86xsHFSoGO+wXNq34H77xHhFlRJTXI4q3",
	"K1Yg4q5CbATZ1yDxVv0BdcOa/lqPBrU/9+XQ4drFViWZHhqmpChcnZ22Klo6Z/v8UCAdATJRoGkeSk0f",
	"L9ONuWnMTWeUm0yPDM9N5il35RkeHxDf2uNA3bLh3BFm+m6Aj9fIntxhc0hnZIw2Ucy8HZLxhYl2BkCn",
	"VPOdnk5u7N2rKz56SGCqtr26anByX3z2my1OzKW8pbHtRW4YcrlQHY7irfUJVDjbjnZr04KKIlKjOL1q",
	"+nV6DZeOR9XZmQHBRw9vU130Fd55FdeQsqODW+bDx/CZmbKe7KF53rIipF4E1oqv6EffT6E47K2QE+8M",
	"xzsdJ3qn47yam2FukHToqAL42qGF6q99MojrMuKbXLbn9bmaIfd5wmtR757TMAc8RxwfcXzE8fPC8bZl",
	"jGCL46qL9wsXXRYtyua7W+N9agsVdlvhWj506i5q7SLOQTct+4D7DN5HndC+njOcyj5WNTLWEGMNMdYQ",
	"Yw3Rca0UXEOsCJYbHl5b+60cc9g7kuOK2LtHwT7ffAA8sBF4qwVkOcXEh3dvuowNK6S0yCJ8m3yWtm5O",
	"p5tE0hxzGa8YT39aYomDJ3s87+KwOCo+WKIpuqcZ1pHX/oqOAY7LHuYlIt4uS5vHjY+FVWxTZlRSnNB/",
	"SYs5q3GQC3/V8Jocs0wSnuFkPin/s4Th5lUfIaguXwfyjqC6pc958UqdnoK65Gkrvzi2F1Z+OeYwWWqJ",
	"n/9c/U3I46vDpeIQwc6yudVndOFXn9GDQ33xdi/DDqLKG0vi9q7Snt+xdmLbLjq+06riSG8gBNQJjduK",
	"fYdRebcQug1uYgESObsICcKfSpff8ARNUYxzGj99QspxDXk9wWCMq6ho3olWsB4kaN5ubCVpLBwBH9KN",
	"xn1MoNujuhNadQFIwhdFIYiiOiYLFKkDQcOxYBR2DuzgMKDxnjpnN9/9FwAA//9gS3asV1oAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
